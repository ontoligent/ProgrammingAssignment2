## cachematrix.R

# The two functions below allow a user to calculate the inverse of a matrix
# and then to cache that value in the same function. The functions demonstrate
# the principle of closures in R. Closures allow programmers to create functions
# that can store persistent results, preventing the need to repeat expensive 
# operationss, and allowing for more efficient code. Here is an example of how
# the two functions are meant to be used:
# > m1 = matrix(c(1,0,0,1),nrow=2,ncol=2) # Create a simple invertible matrix
# > cacheMatrix = makeCacheMatrix(m1)     # Create the matrix function 
# > m2 = cacheSolve(cacheMatrix)          # Get the inverse matrix 
# > m2                                    # See result
# > m3 = matrix(c(1,2,3,0,1,4,4,6,0),nrow=3,ncol=3) # Define a new matrix
# > cacheMatrix$setmatrix(m3)             # Pass to same instance function
# > m4 = cacheSolve(cacheMatrix)          # Get the new inverse matrix 
# > m4                                    # See result

# The function makeCacheMatrix() creates a function that gets and sets a matrix 
# and its inverse, and caches its results. It is a function that creates a 
# function. The produced function we can call the "instance function." A matrix 
# is passed when the instance function is created, or as an argument to its 
# "method" setmatrix(). The instance function is meant to be passed to a calling 
# function, listed below. The variables have the following roles:
# "x" is an invertible matrix, passed to the outer "constructor" as an initial 
# value
# "y" is an invertible matrix, passed to the inner "method" setmatrix() that 
# overwrites x and resets m
# "i" is the inverse of the matrix, stored in the outer closure for cacheing
# "inverse" is the argument passed to setinverse, i.e. the inverse is not 
# calculated internally but by the second function, cacheSolve()
# The instance function returns four "methods" as items of a list. These are:
# setmatrix(y), getmatrix(), setinverse(inverse), and getinverse(). All but 
# setmatrix() are meant to be used by the second function, cacheSolve().
makeCacheMatrix <- function(x = matrix()) {
    i <- NULL
    setmatrix <- function(y) {
        x <<- y
        i <<- NULL
    }
    getmatrix <- function() x
    setinverse <- function(inverse) i <<- inverse
    getinverse <- function() i
    list(setmatrix = setmatrix, getmatrix = getmatrix,
         setinverse = setinverse, getinverse = getinverse)
}

# The function cacheSolve() takes the result of the first function as an 
# argument and returns the inverse of the matrix that was passed to the first.
# If the inverse has already been calculated and cached, the function
# returns the cached matrix. If not, it creates it, caches it, and then
# returns it.The variables have the following roles:
# "f" is an instance function generated by makeCacheMatrix()
# "i" is the calculated and cached inverse matrix, passed between the two
# function.
# "data" is the matrix contained by the passed instance function
# Note that the function solve() will throw an error if the matrix passed
# by the instance function is not invertible. Invertible matrices are 
# a somewhat complicated topic, so you may need to pick a simple example.
cacheSolve <- function(f) {
    i <- f$getinverse()
    if(!is.null(i)) {
        message("getting cached data")
        return(i)
    }
    data <- f$getmatrix()
    i <- solve(data)
    f$setinverse(i)
    i
}